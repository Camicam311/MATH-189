---
title: 'FINAL PROJECT: MATCHING DONORS TO PROJECTS'
output: html_notebook
---

## Kaggle Dataset
[Data Science For Good: DonorsChoose.org](https://www.kaggle.com/donorschoose/io)

***

*Founded in 2000 by a Bronx history teacher, DonorsChoose.org has raised $685 million for America's classrooms. Teachers at three-quarters of all the public schools in the U.S. have come to DonorsChoose.org to request what their students need, making DonorsChoose.org the leading platform for supporting public education.*

*To date, 3 million people and partners have funded 1.1 million DonorsChoose.org projects. But teachers still spend more than a billion dollars of their own money on classroom materials. To get students what they need to learn, the team at DonorsChoose.org needs to be able to connect donors with the projects that most inspire them.*

*In the second Kaggle Data Science for Good challenge, DonorsChoose.org, in partnership with Google.org, is inviting the community to help them pair up donors to the classroom requests that will most motivate them to make an additional gift. To support this challenge, DonorsChoose.org has supplied anonymized data on donor giving from the past five years. The winning methods will be implemented in DonorsChoose.org email marketing campaigns.*

***

#### *Problem Statement*
*DonorsChoose.org has funded over 1.1 million classroom requests through the support of 3 million donors, the majority of whom were making their first-ever donation to a public school. If DonorsChoose.org can motivate even a fraction of those donors to make another donation, that could have a huge impact on the number of classroom requests fulfilled.*

*A good solution will enable DonorsChoose.org to build targeted email campaigns recommending specific classroom requests to prior donors. Part of the challenge is to assess the needs of the organization, uncover insights from the data available, and build the right solution for this problem. Submissions will be evaluated on the following criteria:*

- *Performance - How well does the solution match donors to project requests to which they would be motivated to donate? DonorsChoose.org will not be able to live test every submission, so a strong entry will clearly articulate why it will be effective at motivating repeat donations.*
- *Adaptable - The DonorsChoose.org team wants to put the winning submissions to work, quickly. Therefore a good entry will be easy to implement in production.*
- *Intelligible - A good entry should be easily understood by the DonorsChoose.org team should it need to be updated in the future to accommodate a changing marketplace.*


```{r}
#install.packages(data.table)
#install.packages('tree')
suppressMessages(library(data.table))
library(tree)
```
```{r results='hide'}
donations <- fread('io/Donations.csv')                     # 583.03 MB
donors    <- fread('io/Donors.csv',
                   colClasses=c('Donor Zip'='character'))  # 118.24 MB
projects  <- fread('io/Projects.csv')                      # 2.39 GB
resources <- fread('io/Resources.csv')                     # 781.39 MB
schools   <- fread('io/Schools.csv')                       # 9.21 MB
teachers  <- fread('io/Teachers.csv')                      # 18.66 MB
```
```{r}
#Donations <- data.table::fread("io/Donations.csv")
#projects <- data.table::fread("io/projects_mini.csv")
#schools <-  data.table::fread("io/Schools.csv")[,c(1,3,4)]
#teachers <- data.table::fread("io/Teachers.csv")

# Merge Data Frames
# projects <- data.table::fread("io/Projects.csv")
# projects <- projects[-c(6,7,8,9)]
# write.csv(projects, "io/projects_mini.csv")
# df_merged <- merge(Donations,Donors,by="Donor.ID")
# df_merged <- df_merged[-3]
# df_merged <- merge(df_merged,projects,by="Project.ID")
# df_merged <- merge(df_merged,schools,by="School.ID")
# write.csv(df_merged, "io/df_merged.csv")

#merged <-  aggregate(list(donations=Donations$Donation.Amount), by=list(Project.ID=Donations$Project.ID), FUN= sum)
#merged <- merge(merged,projects, by = "Project.ID")
#merged <- merge(merged,schools, by = "School.ID")
#write.csv(merged, "io/merged_projects.csv")

df <- merge(donations, donors, by='Donor ID')
df
```

```{r}
df <- merge(donations, donors, by=`Project ID`)
df

columns <- NULL
for (table in list(donations, donors, projects, resources, schools, teachers)) {
  columns <- c(columns, colnames(table))
}
sort(unique(columns))
```

```{r}
print(head(donations))
nrow(donors)
print(head(donors))
print(head(projects))
print(head(resources))
print(head(schools))
print(head(teachers))
```
```{r}
sample <- projects[1:1000]
for (row in 1:nrow(sample)) {
  categories <- unlist(strsplit(sample[row]$`Project Subject Category Tree`, ', '))
  if (length(categories) > 1) {
    duplicate <- sample[row]
    sample[row]$`Project Subject Category Tree` <- categories[1]
    for (category in categories[-1]) {
      duplicate$`Project Subject Category Tree` <- category
      sample <- rbindlist(list(sample, modified))
    }
  }
}
sample
```

```{r}
y <- as.factor(sample$`Project Subject Category Tree`)
x1 <- as.factor(sample$`Project Type`)
x2 <- as.numeric(sample$`Project Cost`)
test <- tree(y~x1+x2, data=sample)
plot(test)
text(test)
```

```{r}
```

## EDA
```{r}
set.seed(0)
```


## Classification Tree
-> Probability of donating to the project type
```{r}
colnames(donations)
```


## Import Dataset
```{r}
#Donations <- data.table::fread("io/Donations.csv")
#projects <- data.table::fread("io/projects_mini.csv")
#schools <-  data.table::fread("io/Schools.csv")[,c(1,3,4)]
#teachers <- data.table::fread("io/Teachers.csv")

# Merge Data Frames
# projects <- data.table::fread("io/Projects.csv")
# projects <- projects[-c(6,7,8,9)]
# write.csv(projects, "io/projects_mini.csv")
# df_merged <- merge(Donations,Donors,by="Donor.ID")
# df_merged <- df_merged[-3]
# df_merged <- merge(df_merged,projects,by="Project.ID")
# df_merged <- merge(df_merged,schools,by="School.ID")
# write.csv(df_merged, "io/df_merged.csv")

#merged <-  aggregate(list(donations=Donations$Donation.Amount), by=list(Project.ID=Donations$Project.ID), FUN= sum)
#merged <- merge(merged,projects, by = "Project.ID")
#merged <- merge(merged,schools, by = "School.ID")
#write.csv(merged, "io/merged_projects.csv")
```

## Import Merged Dataset
```{r}
Donors <- data.table::fread("io/Donors.csv")
# Merged dataframe based on Donation.ID
df_merged <- data.table::fread("io/df_merged.csv")
# Merged dataframe based on each Project.ID
merged <- data.table::fread("io/merged_projects.csv")
```

## Extract Unique Category and Subcategory Names
```{r}
# 9 Unique Value for Project Category
unique_category <- c()
for (i in df_merged$Project.Subject.Category.Tree){
    a <- strsplit(i, ", ")[[1]]
    unique_category <- append(unique_category,a)
    unique_category <- unique(unique_category)
}

# 30 Unique Value for Project Subcategory
unique_subcategory <- c()
for (i in df_merged$Project.Subject.Subcategory.Tree){
    a <- strsplit(i, ", ")[[1]]
    unique_subcategory <- append(unique_subcategory,a)
    unique_subcategory <- unique(unique_subcategory)
}
```

## Scenario 1
Question:Is there a seasonal pattern of donations? Is the total amount of received donation related to donation date? Is the total amount of received donation related to day of the week?
```{r}

```


## Scenario 2
Question: Test whether the teachers’ donation pattern is different from non-teachers’ donation pattern (Test whether the fraction of teacher in the whole population is larger than the proportion of the donors that are non teacher).

```{r}
teacher <- df_merged[which(df_merged$Donor.Is.Teacher== 'Yes'),]
nonteacher <- df_merged[which(df_merged$Donor.Is.Teacher=='No'),]
teacher_money_amount <- teacher$Donation.Amount
nonteacher_money_amount <- nonteacher$Donation.Amount
```

2.1 Wilcoxon test- test for the difference in mean
```{r}
# one-sided test- test for difference greater than or equal to 0
# null: true shift is greater than 0 teacher donates more than non-teachers
wilcox.test(teacher_money_amount, nonteacher_money_amount, paired = FALSE, correct = FALSE)
wilcox.test(teacher_money_amount, nonteacher_money_amount, paired = FALSE, correct = FALSE, alternative = "less")
```

2.2 True fraction of teacher donors in the donor population
```{r}
teacher.donor.fraction <- round(as.numeric(table(Donors[,`Donor Is Teacher`])[2])/nrow(Donors)*100, 3)
print(paste0("The true fraction of teacher donors is ", teacher.donor.fraction, "%"))

# EDA: Check if teacher donors' donation pattern(except for the ones who only donate 1 dollar) follow normal distribution
t <- sample(teacher$Donation.Amount, 10000)
tt <- teacher[which(teacher$Donation.Amount<500 & teacher$Donation.Amount>1),6]$Donation.Amount
qqplot(log(tt), rnorm(length(tt), mean(log(tt)), var(log(tt))))
abline(0, 1)
hist(log(tt))
```


## Scenario 3
Question: Which state has the highest donor to population ratio? Is the amount of donation correlated with the region donors live in?
```{r}

```


## Scenario 4
Predict donors' donating behaviors to figure out how much a donor would donate for a project. 
4.1 In total, find out the states that have the most donations.
```{r}
# Figure out the rank of total donation amount for each state
state.total <-  aggregate(list(donations=df_merged$Donation.Amount), by=list(states=df_merged$Donor.State), FUN= sum)
state.total <-  state.total[order(state.total$donations, decreasing = TRUE),]
summary(state.total$donations)
```

4.2 On average, find out the states that have the most donation per transaction.
```{r}
# Figure out the rank of average donation amount per transaction for each state
state.avg <-  aggregate(list(donations=df_merged$Donation.Amount), by=list(states=df_merged$Donor.State), FUN= mean)
state.avg <- state.avg[order(state.avg$donations, decreasing = TRUE),]
summary(state.avg$donations)
```

4.3 Least Square Regression on predicting how much a donor will donate 
```{r}
sample <- merged[sample(nrow(merged), 100000), ]
sample=na.omit(sample)
ols = lm(formula = donations ~ Project.Type + Project.Grade.Level.Category+ Project.Cost+ School.Metro.Type + School.Percentage.Free.Lunch  , data = sample)
summary(ols)
```

4.4 Ridge Regression on predicting how much a donor will donate 
```{r}
# Ridge
#install.packages("MASS")
library(MASS)
ridge <- lm.ridge (donations ~ Project.Type + Project.Cost + School.Metro.Type + School.Percentage.Free.Lunch, data = sample, lambda = seq(0, 50, .001))
plot(ridge)
select(ridge)
```
```{r}
# install.packages("ISLR")
# install.packages("glmnet")
library("glmnet")
library(ISLR)
set.seed(2018)

sample = sample[c(4,7,10,11,17,18)]
x=model.matrix(donations~.-1,data=sample) 
y=sample$donations
fit.ridge=glmnet(x,y,alpha=0)
plot(fit.ridge,xvar="lambda",label=TRUE)
cv.ridge=cv.glmnet(x,y,alpha=0)
plot(cv.ridge)
```

4.5 Lasso Regression on predicting how much a donor will donate 
```{r}
fit.lasso=glmnet(x,y,alpha=1)
plot(fit.lasso,xvar="lambda",label=TRUE)
cv.lasso=cv.glmnet(x,y)
plot(cv.lasso)
coef(cv.lasso)
n <- nrow(x)
train <- sample(1:n, size = floor(0.6*n), replace = FALSE) # use 60% data for training
lasso.tr=glmnet(x[train,],y[train], alpha = 1)
lasso.tr
pred=predict(lasso.tr,x[-train,])
# calculate the mse
rmse= sqrt(apply((y[-train]-pred)^2,2,mean))
plot(log(lasso.tr$lambda),rmse,type="b",xlab="Log(lambda)")
lam.best=lasso.tr$lambda[order(rmse)[1]]
lam.best
coef(lasso.tr,s=lam.best)
```


## Scenario 5
Forests/ Bagging(Include Cross Validation)/ clustering - Predict how likely the donor is going to donate. 

5.1 Random Forests
```{r}
#install.packages('randomForest')
library(randomForest)

n <- nrow(sample)
train <- sample(1:n, size = floor(0.75*n), replace = FALSE) # use 75% data for training
rf.fit <- randomForest(donations ~ ., data = sample[train, ], importance = TRUE, ntree = 1000, nodesize = 10)
varImpPlot(rf.fit)
rf.pred <- predict(rf.fit, sample[-train, ], type = 'response')
# MSE
print(mean((rf.pred - sample[-train, ]$donations)^2))
print(mean(abs(rf.pred - sample[-train, ]$donations)))
print(mean(abs(rf.pred - sample[-train, ]$donations)/sample[-train, ]$donations))
```

5.2 K-Mean Clustering
```{r}
library(ggplot2)
ggplot(sample, aes(School.Percentage.Free.Lunch,donations, color = School.Metro.Type)) + geom_point()
set.seed(314)
irisCluster <- kmeans(iris[, c(1,3)], 3, nstart = 20)
irisCluster
```

## Scenario 6
6.1 Test of Independence Test if the funding duration time is independent of project cost
```{r}
# Clean out the outliers
test <- merged[which(merged$Project.Current.Status == 'Fully Funded'),c(4,12,13,14,16)]
test$expire.duration <- as.numeric(as.Date(test$Project.Expiration.Date)-as.Date(test$Project.Posted.Date))
test$funded.duration <- as.numeric(as.Date(test$Project.Fully.Funded.Date)-as.Date(test$Project.Posted.Date))
test <- test[,-c(3,4,5)]
outlier.upper <- as.numeric(apply(test, FUN = mean, MARGIN = 2)+ 3* apply(test, FUN = sd, MARGIN = 2))
outlier.lower <- as.numeric(apply(test, FUN = mean, MARGIN = 2)- 3* apply(test, FUN = sd, MARGIN = 2))

test <- test[which(donations<outlier.upper[1]),]
test <- test[which(donations>outlier.lower[1]),]
test <- test[which(Project.Cost<outlier.upper[2]),]
test <- test[which(Project.Cost>outlier.lower[2]),]
test <- test[which(expire.duration<outlier.upper[3]),]
test <- test[which(expire.duration>outlier.lower[3]),]
test <- test[which(funded.duration<outlier.upper[4]),]
test <- test[which(funded.duration>outlier.lower[4]),]

# Attempt for a for loop but failed
for (i in c(1:length(outlier.lower))){
  test <- test[which(test[,i]>outlier.lower[i]),]
  test <- test[which(test[,i]<outlier.upper[i]),]
}

```

```{r}
par(mfrow=c(1,2))
boxplot(test[,c(1,2)])
boxplot(test[,c(3,4)])

par(mfrow=c(2,3))
hist(test$expire.duration)
hist(test$funded.duration)
hist(test$donations)
hist(test$Project.Cost)
hist(log(test$Project.Cost))
hist(log(test$donations))

par(mfrow= c(2,2))
qqplot(test$donations,test$Project.Cost)
qqplot(test$donations,test$expire.duration)
qqplot(test$donations, test$funded.duration)
qqplot(test$Project.Cost,test$funded.duration)

par(mfrow = c(1,1))
test_avg <- aggregate(list(donations=test$donations), by=list(Project.Cost=round(test$Project.Cost)), FUN=mean)
test_avg <- test_avg[which(test_avg<=1590),]
least.squares <- lm(donations~Project.Cost, data=test_avg)
plot(test_avg$Project.Cost, test_avg$donations)
abline(least.squares, col='red')
summary(least.squares)
```
